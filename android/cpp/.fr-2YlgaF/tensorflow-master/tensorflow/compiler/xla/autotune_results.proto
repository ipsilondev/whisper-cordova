/* Copyright 2022 The TensorFlow Authors. All Rights Reserved.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
==============================================================================*/

syntax = "proto3";

package xla;

import "tensorflow/tsl/protobuf/autotuning.proto";

// A collection of algorithms for particular dot/convs.  Usually this is "the
// best" algorithm for the particular dot/conv, although that's not strictly
// required.
//
// Users don't interact with this proto directly.  It's used internally to
// facilitate ahead-of-time autotuning -- The string used by
// xla::{Serialize,Load}AutotuneResults is, internally, a serialization of this
// proto.
//
// LINT.IfChange
message AutotuneResults {
  message Entry {
    string device = 1;
    string hlo = 2;

    // nb: These results are always tied to a particular version of
    // cublas/cudnn, but this is *especially* true for cublasLt results.  For
    // cublasLt gemms, the result is an index into the list of candidate
    // algorithms returned by cublasLt.  Different version of cublasLt ->
    // different list of algos -> different interpretation of results!
    tensorflow.AutotuneResult result = 3;
  }

  int32 version = 1;
  repeated Entry dots = 2;
  repeated Entry convs = 3;
}
// LINT.ThenChange(
//   "autotune_serialize.cc:version"
// )
