// RUN: hlo_to_llvm_ir %s | FileCheck %s

// NOTE: Assertions have been autogenerated by utils/generate-test-checks.py

// CHECK-LABEL: entry:
// CHECK:         %[[VAL_0:.*]] = getelementptr inbounds i8, ptr %[[VAL_1:.*]], i64 0
// CHECK:         %[[VAL_2:.*]] = getelementptr inbounds i8, ptr %[[VAL_3:.*]], i64 0
// CHECK:         %[[VAL_4:.*]] = getelementptr inbounds i8, ptr %[[VAL_5:.*]], i64 0
// CHECK:         %[[VAL_6:.*]] = getelementptr inbounds i8, ptr %[[VAL_7:.*]], i64 0
// CHECK:         %[[VAL_8:.*]] = getelementptr inbounds i8, ptr %[[VAL_9:.*]], i64 0
// CHECK:         %[[VAL_10:.*]] = getelementptr inbounds i8, ptr %[[VAL_0]], i32 32
// CHECK:         %[[VAL_11:.*]] = load i32, ptr %[[VAL_10]], align 4
// CHECK:         %[[VAL_12:.*]] = getelementptr inbounds i8, ptr %[[VAL_0]], i32 36
// CHECK:         %[[VAL_13:.*]] = load i32, ptr %[[VAL_12]], align 4
// CHECK:         %[[VAL_14:.*]] = getelementptr inbounds i8, ptr %[[VAL_0]], i32 40
// CHECK:         %[[VAL_15:.*]] = load i32, ptr %[[VAL_14]], align 4
// CHECK:         %[[VAL_16:.*]] = call i32 @llvm.nvvm.read.ptx.sreg.tid.x()
// CHECK:         %[[VAL_17:.*]] = icmp eq i32 0, %[[VAL_16]]
// CHECK:         %[[VAL_18:.*]] = call i32 @llvm.nvvm.read.ptx.sreg.ctaid.x()
// CHECK:         %[[VAL_19:.*]] = icmp eq i32 0, %[[VAL_18]]
// CHECK:         %[[VAL_20:.*]] = and i1 %[[VAL_17]], %[[VAL_19]]
// CHECK:         br i1 %[[VAL_20]], label %[[VAL_21:.*]], label %[[VAL_22:.*]]
// CHECK:       is_thread_0-after:                                ; preds = %[[VAL_21]], %[[VAL_23:.*]]
// CHECK:         %[[VAL_24:.*]] = mul i32 1, %[[VAL_11]]
// CHECK:         %[[VAL_25:.*]] = mul i32 %[[VAL_24]], %[[VAL_13]]
// CHECK:         %[[VAL_26:.*]] = mul i32 %[[VAL_25]], %[[VAL_15]]
// CHECK:         %[[VAL_27:.*]] = call i32 @llvm.nvvm.read.ptx.sreg.ctaid.x(), !range !2
// CHECK:         %[[VAL_28:.*]] = call i32 @llvm.nvvm.read.ptx.sreg.tid.x(), !range !3
// CHECK:         %[[VAL_29:.*]] = mul nuw nsw i32 %[[VAL_27]], 8
// CHECK:         %[[VAL_30:.*]] = add nuw nsw i32 %[[VAL_29]], %[[VAL_28]]
// CHECK:         %[[VAL_31:.*]] = icmp ult i32 %[[VAL_30]], 8
// CHECK:         call void @llvm.assume(i1 %[[VAL_31]])
// CHECK:         %[[VAL_32:.*]] = udiv i32 %[[VAL_30]], 1
// CHECK:         %[[VAL_33:.*]] = urem i32 %[[VAL_32]], 2
// CHECK:         %[[VAL_34:.*]] = udiv i32 %[[VAL_30]], 2
// CHECK:         %[[VAL_35:.*]] = urem i32 %[[VAL_34]], 2
// CHECK:         %[[VAL_36:.*]] = udiv i32 %[[VAL_30]], 4
// CHECK:         %[[VAL_37:.*]] = icmp ult i32 %[[VAL_30]], 8
// CHECK:         br i1 %[[VAL_37]], label %[[VAL_38:.*]], label %[[VAL_39:.*]]
// CHECK:       custom_call_2.in_bounds-after:                    ; preds = %[[VAL_40:.*]], %[[VAL_22]]
// CHECK:         ret void
// CHECK:       is_thread_0-true:                                 ; preds = %[[VAL_23]]
// CHECK:         store i32 %[[VAL_11]], ptr %[[VAL_4]], align 4
// CHECK:         store i32 %[[VAL_13]], ptr %[[VAL_6]], align 4
// CHECK:         store i32 %[[VAL_15]], ptr %[[VAL_8]], align 4
// CHECK:         br label %[[VAL_22]]
// CHECK:       custom_call_2.in_bounds-true:                     ; preds = %[[VAL_22]]
// CHECK:         %[[VAL_41:.*]] = mul nuw nsw i32 %[[VAL_33]], 1
// CHECK:         %[[VAL_42:.*]] = add nuw nsw i32 0, %[[VAL_41]]
// CHECK:         %[[VAL_43:.*]] = mul nuw nsw i32 %[[VAL_35]], 2
// CHECK:         %[[VAL_44:.*]] = add nuw nsw i32 %[[VAL_42]], %[[VAL_43]]
// CHECK:         %[[VAL_45:.*]] = mul nuw nsw i32 %[[VAL_36]], 4
// CHECK:         %[[VAL_46:.*]] = add nuw nsw i32 %[[VAL_44]], %[[VAL_45]]
// CHECK:         %[[VAL_47:.*]] = icmp ult i32 %[[VAL_46]], %[[VAL_26]]
// CHECK:         br i1 %[[VAL_47]], label %[[VAL_48:.*]], label %[[VAL_40]]
// CHECK:       custom_call_2.in_dyn_bounds-after:                ; preds = %[[VAL_48]], %[[VAL_38]]
// CHECK:         br label %[[VAL_39]]
// CHECK:       custom_call_2.in_dyn_bounds-true:                 ; preds = %[[VAL_38]]
// CHECK:         %[[VAL_49:.*]] = udiv i32 %[[VAL_46]], 1
// CHECK:         %[[VAL_50:.*]] = urem i32 %[[VAL_49]], %[[VAL_15]]
// CHECK:         %[[VAL_51:.*]] = mul i32 1, %[[VAL_15]]
// CHECK:         %[[VAL_52:.*]] = udiv i32 %[[VAL_46]], %[[VAL_51]]
// CHECK:         %[[VAL_53:.*]] = urem i32 %[[VAL_52]], %[[VAL_13]]
// CHECK:         %[[VAL_54:.*]] = mul i32 %[[VAL_51]], %[[VAL_13]]
// CHECK:         %[[VAL_55:.*]] = udiv i32 %[[VAL_46]], %[[VAL_54]]
// CHECK:         %[[VAL_56:.*]] = getelementptr inbounds i32, ptr %[[VAL_0]], i32 %[[VAL_30]]
// CHECK:         %[[VAL_57:.*]] = load i32, ptr %[[VAL_56]], align 4, !invariant.load !4
// CHECK:         %[[VAL_58:.*]] = getelementptr inbounds [2 x [2 x [2 x i32]]], ptr %[[VAL_2]], i32 0, i32 %[[VAL_55]], i32 %[[VAL_53]], i32 %[[VAL_50]]
// CHECK:         store i32 %[[VAL_57]], ptr %[[VAL_58]], align 4
// CHECK:         br label %[[VAL_40]]


HloModule PadToStatic

ENTRY main {
  %param = s32[2,<=2,2] parameter(0)
  ROOT %custom_call_2 = (s32[2,2,2], s32[], s32[], s32[])
             custom-call(s32[2,<=2,2] %param),
             custom_call_target="PadToStatic"
}
