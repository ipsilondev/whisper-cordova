// RUN: hlo_to_llvm_ir %s | FileCheck %s

// NOTE: Assertions have been autogenerated by utils/generate-test-checks.py

// CHECK-LABEL: entry:
// CHECK:         %[[VAL_0:.*]] = getelementptr inbounds i8, ptr %[[VAL_1:.*]], i64 0
// CHECK:         %[[VAL_2:.*]] = getelementptr inbounds i8, ptr %[[VAL_3:.*]], i64 0
// CHECK:         %[[VAL_4:.*]] = getelementptr inbounds i8, ptr %[[VAL_5:.*]], i64 0
// CHECK:         %[[VAL_6:.*]] = getelementptr inbounds i8, ptr %[[VAL_7:.*]], i64 0
// CHECK:         %[[VAL_8:.*]] = getelementptr inbounds i8, ptr %[[VAL_9:.*]], i64 0
// CHECK:         %[[VAL_10:.*]] = getelementptr inbounds i8, ptr %[[VAL_11:.*]], i64 0
// CHECK:         %[[VAL_12:.*]] = getelementptr inbounds i8, ptr %[[VAL_13:.*]], i64 0
// CHECK:         %[[VAL_14:.*]] = call i32 @llvm.nvvm.read.ptx.sreg.ctaid.x(), !range !2
// CHECK:         %[[VAL_15:.*]] = call i32 @llvm.nvvm.read.ptx.sreg.tid.x(), !range !3
// CHECK:         %[[VAL_16:.*]] = mul nuw nsw i32 %[[VAL_14]], 1024
// CHECK:         %[[VAL_17:.*]] = add nuw nsw i32 %[[VAL_16]], %[[VAL_15]]
// CHECK:         %[[VAL_18:.*]] = icmp ult i32 %[[VAL_17]], 2048
// CHECK:         call void @llvm.assume(i1 %[[VAL_18]])
// CHECK:         %[[VAL_19:.*]] = udiv i32 %[[VAL_17]], 1
// CHECK:         %[[VAL_20:.*]] = icmp ult i32 %[[VAL_17]], 2047
// CHECK:         br i1 %[[VAL_20]], label %[[VAL_21:.*]], label %[[VAL_22:.*]]
// CHECK:       fusion.in_bounds-after:                           ; preds = %[[VAL_23:.*]], %[[VAL_24:.*]]
// CHECK:         ret void
// CHECK:       fusion.in_bounds-true:                            ; preds = %[[VAL_24]]
// CHECK:         br label %[[VAL_25:.*]]
// CHECK:       concat_index_from_operand_id0:                    ; preds = %[[VAL_26:.*]]
// CHECK:         %[[VAL_27:.*]] = phi i32 [ 0, %[[VAL_26]] ]
// CHECK:         %[[VAL_28:.*]] = sub nsw i32 %[[VAL_19]], %[[VAL_27]]
// CHECK:         %[[VAL_29:.*]] = getelementptr inbounds [1024 x half], ptr %[[VAL_0]], i32 0, i32 %[[VAL_28]]
// CHECK:         %[[VAL_30:.*]] = load half, ptr %[[VAL_29]], align 2, !invariant.load !4
// CHECK:         %[[VAL_31:.*]] = getelementptr inbounds [1024 x half], ptr %[[VAL_2]], i32 0, i32 %[[VAL_28]]
// CHECK:         %[[VAL_32:.*]] = load half, ptr %[[VAL_31]], align 2, !invariant.load !4
// CHECK:         %[[VAL_33:.*]] = fmul half %[[VAL_30]], %[[VAL_32]]
// CHECK:         br label %[[VAL_34:.*]]
// CHECK:       concat_index_from_operand_id1:                    ; preds = %[[VAL_35:.*]]
// CHECK:         %[[VAL_36:.*]] = phi i32 [ 1024, %[[VAL_35]] ]
// CHECK:         %[[VAL_37:.*]] = sub nsw i32 %[[VAL_19]], %[[VAL_36]]
// CHECK:         %[[VAL_38:.*]] = getelementptr inbounds [1023 x half], ptr %[[VAL_4]], i32 0, i32 %[[VAL_37]]
// CHECK:         %[[VAL_39:.*]] = load half, ptr %[[VAL_38]], align 2, !invariant.load !4
// CHECK:         %[[VAL_40:.*]] = getelementptr inbounds [1023 x half], ptr %[[VAL_6]], i32 0, i32 %[[VAL_37]]
// CHECK:         %[[VAL_41:.*]] = load half, ptr %[[VAL_40]], align 2, !invariant.load !4
// CHECK:         %[[VAL_42:.*]] = fadd half %[[VAL_39]], %[[VAL_41]]
// CHECK:         br label %[[VAL_34]]
// CHECK:       concatenate.pivot.1024.:                          ; preds = %[[VAL_21]]
// CHECK:         %[[VAL_43:.*]] = icmp ult i32 %[[VAL_19]], 1024
// CHECK:         br i1 %[[VAL_43]], label %[[VAL_26]], label %[[VAL_35]]
// CHECK:       concatenate.pivot.0.:                             ; preds = %[[VAL_25]]
// CHECK:         br label %[[VAL_44:.*]]
// CHECK:       concatenate.pivot.1024.1:                         ; preds = %[[VAL_25]]
// CHECK:         br label %[[VAL_45:.*]]
// CHECK:       concatenate.7.merge:                              ; preds = %[[VAL_45]], %[[VAL_44]]
// CHECK:         %[[VAL_46:.*]] = phi half [ %[[VAL_33]], %[[VAL_44]] ], [ %[[VAL_42]], %[[VAL_45]] ]
// CHECK:         %[[VAL_47:.*]] = icmp sge i32 %[[VAL_19]], 0
// CHECK:         %[[VAL_48:.*]] = icmp slt i32 %[[VAL_19]], 1024
// CHECK:         %[[VAL_49:.*]] = and i1 %[[VAL_47]], %[[VAL_48]]
// CHECK:         br i1 %[[VAL_49]], label %[[VAL_50:.*]], label %[[VAL_51:.*]]
// CHECK:       slice0-after:                                     ; preds = %[[VAL_50]], %[[VAL_34]]
// CHECK:         %[[VAL_52:.*]] = icmp sge i32 %[[VAL_19]], 1024
// CHECK:         %[[VAL_53:.*]] = icmp slt i32 %[[VAL_19]], 2047
// CHECK:         %[[VAL_54:.*]] = and i1 %[[VAL_52]], %[[VAL_53]]
// CHECK:         br i1 %[[VAL_54]], label %[[VAL_55:.*]], label %[[VAL_56:.*]]
// CHECK:       slice1-after:                                     ; preds = %[[VAL_55]], %[[VAL_51]]
// CHECK:         %[[VAL_57:.*]] = icmp sge i32 %[[VAL_19]], 2047
// CHECK:         %[[VAL_58:.*]] = icmp slt i32 %[[VAL_19]], 2047
// CHECK:         %[[VAL_59:.*]] = and i1 %[[VAL_57]], %[[VAL_58]]
// CHECK:         br i1 %[[VAL_59]], label %[[VAL_60:.*]], label %[[VAL_23]]
// CHECK:       slice2-after:                                     ; preds = %[[VAL_60]], %[[VAL_56]]
// CHECK:         br label %[[VAL_22]]
// CHECK:       slice0-true:                                      ; preds = %[[VAL_34]]
// CHECK:         %[[VAL_61:.*]] = sub i32 %[[VAL_19]], 0
// CHECK:         %[[VAL_62:.*]] = getelementptr inbounds [1024 x half], ptr %[[VAL_8]], i32 0, i32 %[[VAL_61]]
// CHECK:         store half %[[VAL_46]], ptr %[[VAL_62]], align 2
// CHECK:         br label %[[VAL_51]]
// CHECK:       slice1-true:                                      ; preds = %[[VAL_51]]
// CHECK:         %[[VAL_63:.*]] = sub i32 %[[VAL_19]], 1024
// CHECK:         %[[VAL_64:.*]] = getelementptr inbounds [1023 x half], ptr %[[VAL_10]], i32 0, i32 %[[VAL_63]]
// CHECK:         store half %[[VAL_46]], ptr %[[VAL_64]], align 2
// CHECK:         br label %[[VAL_56]]
// CHECK:       slice2-true:                                      ; preds = %[[VAL_56]]
// CHECK:         %[[VAL_65:.*]] = sub i32 %[[VAL_19]], 2047
// CHECK:         %[[VAL_66:.*]] = getelementptr inbounds [0 x half], ptr %[[VAL_12]], i32 0, i32 %[[VAL_65]]
// CHECK:         store half %[[VAL_46]], ptr %[[VAL_66]], align 2
// CHECK:         br label %[[VAL_23]]


HloModule input_fusion_with_a_tuple_of_slices

fused_computation {
  arg.1 = f16[1024]{0} parameter(0)
  arg.2 = f16[1024]{0} parameter(1)
  arg.3 = f16[1023]{0} parameter(2)
  arg.4 = f16[1023]{0} parameter(3)
  mul.1 = f16[1024]{0} multiply(arg.1, arg.2)
  add.1 = f16[1023]{0} add(arg.3, arg.4)
  concat.1 = f16[2047]{0} concatenate(mul.1, add.1), dimensions={0}
  slice.1 = f16[1024]{0} slice(concat.1), slice={[0:1024]}
  slice.2 = f16[1023]{0} slice(concat.1), slice={[1024:2047]}
  slice.3 = f16[0]{0} slice(concat.1), slice={[2047:2047]}
  ROOT tuple.1 = (f16[1024]{0}, f16[1023]{0}, f16[0]{0})
      tuple(slice.1, slice.2, slice.3)
}

ENTRY kernel_entry {
  arg.1 = f16[1024]{0} parameter(0)
  arg.2 = f16[1024]{0} parameter(1)
  arg.3 = f16[1023]{0} parameter(2)
  arg.4 = f16[1023]{0} parameter(3)
  ROOT fusion = (f16[1024]{0}, f16[1023]{0}, f16[0]{0})
      fusion(arg.1, arg.2, arg.3, arg.4), kind=kInput, calls=fused_computation
}
