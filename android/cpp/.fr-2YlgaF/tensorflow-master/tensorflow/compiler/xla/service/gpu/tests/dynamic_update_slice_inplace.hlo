// RUN: hlo_to_llvm_ir %s | FileCheck %s

// NOTE: Assertions have been autogenerated by utils/generate-test-checks.py

// CHECK-LABEL: entry:
// CHECK:         %[[VAL_0:.*]] = getelementptr inbounds i8, ptr %[[VAL_1:.*]], i64 0
// CHECK:         %[[VAL_2:.*]] = getelementptr inbounds i8, ptr %[[VAL_3:.*]], i64 0
// CHECK:         %[[VAL_4:.*]] = getelementptr inbounds i8, ptr %[[VAL_1]], i64 0
// CHECK:         %[[VAL_5:.*]] = load i32, ptr @0, align 4
// CHECK:         %[[VAL_6:.*]] = icmp sge i32 0, %[[VAL_5]]
// CHECK:         %[[VAL_7:.*]] = select i1 %[[VAL_6]], i32 0, i32 %[[VAL_5]]
// CHECK:         %[[VAL_8:.*]] = icmp sle i32 49, %[[VAL_7]]
// CHECK:         %[[VAL_9:.*]] = select i1 %[[VAL_8]], i32 49, i32 %[[VAL_7]]
// CHECK:         %[[VAL_10:.*]] = load i32, ptr @0, align 4
// CHECK:         %[[VAL_11:.*]] = icmp sge i32 0, %[[VAL_10]]
// CHECK:         %[[VAL_12:.*]] = select i1 %[[VAL_11]], i32 0, i32 %[[VAL_10]]
// CHECK:         %[[VAL_13:.*]] = icmp sle i32 0, %[[VAL_12]]
// CHECK:         %[[VAL_14:.*]] = select i1 %[[VAL_13]], i32 0, i32 %[[VAL_12]]
// CHECK:         %[[VAL_15:.*]] = load i32, ptr @0, align 4
// CHECK:         %[[VAL_16:.*]] = icmp sge i32 0, %[[VAL_15]]
// CHECK:         %[[VAL_17:.*]] = select i1 %[[VAL_16]], i32 0, i32 %[[VAL_15]]
// CHECK:         %[[VAL_18:.*]] = icmp sle i32 0, %[[VAL_17]]
// CHECK:         %[[VAL_19:.*]] = select i1 %[[VAL_18]], i32 0, i32 %[[VAL_17]]
// CHECK:         %[[VAL_20:.*]] = call i32 @llvm.nvvm.read.ptx.sreg.ctaid.x(), !range !2
// CHECK:         %[[VAL_21:.*]] = zext i32 %[[VAL_20]] to i64
// CHECK:         %[[VAL_22:.*]] = call i32 @llvm.nvvm.read.ptx.sreg.tid.x(), !range !3
// CHECK:         %[[VAL_23:.*]] = zext i32 %[[VAL_22]] to i64
// CHECK:         %[[VAL_24:.*]] = mul nuw nsw i64 %[[VAL_21]], 1024
// CHECK:         %[[VAL_25:.*]] = add nuw nsw i64 %[[VAL_24]], %[[VAL_23]]
// CHECK:         %[[VAL_26:.*]] = icmp ult i64 %[[VAL_25]], 98304
// CHECK:         call void @llvm.assume(i1 %[[VAL_26]])
// CHECK:         %[[VAL_27:.*]] = udiv i64 %[[VAL_25]], 1
// CHECK:         %[[VAL_28:.*]] = urem i64 %[[VAL_27]], 1024
// CHECK:         %[[VAL_29:.*]] = udiv i64 %[[VAL_25]], 1024
// CHECK:         %[[VAL_30:.*]] = urem i64 %[[VAL_29]], 96
// CHECK:         %[[VAL_31:.*]] = udiv i64 %[[VAL_25]], 98304
// CHECK:         %[[VAL_32:.*]] = icmp ult i64 %[[VAL_25]], 98304
// CHECK:         br i1 %[[VAL_32]], label %[[VAL_33:.*]], label %[[VAL_34:.*]]
// CHECK:       dynamic-update-slice.4.in_bounds-after:           ; preds = %[[VAL_33]], %[[VAL_35:.*]]
// CHECK:         ret void
// CHECK:       dynamic-update-slice.4.in_bounds-true:            ; preds = %[[VAL_35]]
// CHECK:         %[[VAL_36:.*]] = sext i32 %[[VAL_9]] to i64
// CHECK:         %[[VAL_37:.*]] = add i64 %[[VAL_36]], %[[VAL_31]]
// CHECK:         %[[VAL_38:.*]] = sext i32 %[[VAL_14]] to i64
// CHECK:         %[[VAL_39:.*]] = add i64 %[[VAL_38]], %[[VAL_30]]
// CHECK:         %[[VAL_40:.*]] = sext i32 %[[VAL_19]] to i64
// CHECK:         %[[VAL_41:.*]] = add i64 %[[VAL_40]], %[[VAL_28]]
// CHECK:         %[[VAL_42:.*]] = getelementptr inbounds half, ptr %[[VAL_2]], i64 %[[VAL_25]]
// CHECK:         %[[VAL_43:.*]] = load half, ptr %[[VAL_42]], align 2, !invariant.load !4
// CHECK:         %[[VAL_44:.*]] = getelementptr inbounds [50 x [96 x [1024 x half]]], ptr %[[VAL_4]], i64 0, i64 %[[VAL_37]], i64 %[[VAL_39]], i64 %[[VAL_41]]
// CHECK:         store half %[[VAL_43]], ptr %[[VAL_44]], align 2
// CHECK:         br label %[[VAL_34]]

HloModule TestModule

fusion.1 {
  p.0 = f16[50,96,1024]{2,1,0} parameter(0)
  p.1 = f16[1,96,1024]{2,1,0} parameter(1)
  c.0 = s32[] constant(0)
  ROOT %dynamic-update-slice = f16[50,96,1024]{2,1,0} dynamic-update-slice(p.0, p.1, c.0, c.0, c.0)
}

ENTRY entry {
  p.0 = f16[50,96,1024]{2,1,0} parameter(0)
  p.1 = f16[1,96,1024]{2,1,0} parameter(1)
  ROOT f1 = f16[50,96,1024] fusion(p.0, p.1), kind=kLoop, calls=fusion.1
}
