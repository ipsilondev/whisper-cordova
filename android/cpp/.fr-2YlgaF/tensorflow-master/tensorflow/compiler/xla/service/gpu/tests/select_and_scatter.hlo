// RUN: hlo_to_llvm_ir %s | FileCheck %s

// NOTE: Assertions have been autogenerated by utils/generate-test-checks.py

// CHECK-LABEL: entry:
// CHECK:         %[[VAL_0:.*]] = alloca i8, align 1
// CHECK:         %[[VAL_1:.*]] = alloca i32, align 4
// CHECK:         %[[VAL_2:.*]] = alloca i1, align 1
// CHECK:         %[[VAL_3:.*]] = alloca i32, align 4
// CHECK:         %[[VAL_4:.*]] = alloca float, align 4
// CHECK:         %[[VAL_5:.*]] = getelementptr inbounds i8, ptr %[[VAL_6:.*]], i64 0
// CHECK:         %[[VAL_7:.*]] = getelementptr inbounds i8, ptr %[[VAL_8:.*]], i64 0
// CHECK:         %[[VAL_9:.*]] = getelementptr inbounds i8, ptr %[[VAL_10:.*]], i64 0
// CHECK:         %[[VAL_11:.*]] = call i32 @llvm.nvvm.read.ptx.sreg.ctaid.x(), !range !2
// CHECK:         %[[VAL_12:.*]] = call i32 @llvm.nvvm.read.ptx.sreg.tid.x(), !range !3
// CHECK:         %[[VAL_13:.*]] = mul nuw nsw i32 %[[VAL_11]], 2
// CHECK:         %[[VAL_14:.*]] = add nuw nsw i32 %[[VAL_13]], %[[VAL_12]]
// CHECK:         %[[VAL_15:.*]] = icmp ult i32 %[[VAL_14]], 2
// CHECK:         call void @llvm.assume(i1 %[[VAL_15]])
// CHECK:         %[[VAL_16:.*]] = udiv i32 %[[VAL_14]], 1
// CHECK:         %[[VAL_17:.*]] = icmp ult i32 %[[VAL_14]], 2
// CHECK:         br i1 %[[VAL_17]], label %[[VAL_18:.*]], label %[[VAL_19:.*]]
// CHECK:       select_and_scatter_12.in_bounds-after:            ; preds = %[[VAL_20:.*]], %[[VAL_21:.*]]
// CHECK:         ret void
// CHECK:       select_and_scatter_12.in_bounds-true:             ; preds = %[[VAL_21]]
// CHECK:         store i1 false, ptr %[[VAL_2]], align 1
// CHECK:         store i32 0, ptr %[[VAL_1]], align 4
// CHECK:         br label %[[VAL_22:.*]]
// CHECK:       select_and_scatter_12inner.loop_header.window.0:  ; preds = %[[VAL_23:.*]], %[[VAL_18]]
// CHECK:         %[[VAL_24:.*]] = load i32, ptr %[[VAL_1]], align 4
// CHECK:         %[[VAL_25:.*]] = icmp uge i32 %[[VAL_24]], 3
// CHECK:         br i1 %[[VAL_25]], label %[[VAL_26:.*]], label %[[VAL_27:.*]]
// CHECK:       select_and_scatter_12inner.loop_body.window.0:    ; preds = %[[VAL_22]]
// CHECK:         %[[VAL_28:.*]] = mul nsw i32 %[[VAL_16]], 3
// CHECK:         %[[VAL_29:.*]] = add nsw i32 %[[VAL_28]], %[[VAL_24]]
// CHECK:         %[[VAL_30:.*]] = sub nsw i32 %[[VAL_29]], 0
// CHECK:         %[[VAL_31:.*]] = icmp ult i32 %[[VAL_30]], 6
// CHECK:         %[[VAL_32:.*]] = and i1 true, %[[VAL_31]]
// CHECK:         br i1 %[[VAL_32]], label %[[VAL_33:.*]], label %[[VAL_34:.*]]
// CHECK:       in-bounds-after:                                  ; preds = %[[VAL_34]], %[[VAL_35:.*]]
// CHECK:         %[[VAL_36:.*]] = add nuw nsw i32 %[[VAL_24]], 1
// CHECK:         store i32 %[[VAL_36]], ptr %[[VAL_1]], align 4
// CHECK:         br label %[[VAL_22]]
// CHECK:       select_and_scatter_12inner.loop_exit.window.0:    ; preds = %[[VAL_22]]
// CHECK:         %[[VAL_37:.*]] = load i1, ptr %[[VAL_2]], align 1
// CHECK:         br i1 %[[VAL_37]], label %[[VAL_38:.*]], label %[[VAL_20]]
// CHECK:       should-store-after:                               ; preds = %[[VAL_38]], %[[VAL_26]]
// CHECK:         br label %[[VAL_19]]
// CHECK:       in-bounds-true:                                   ; preds = %[[VAL_27]]
// CHECK:         %[[VAL_39:.*]] = load i1, ptr %[[VAL_2]], align 1
// CHECK:         br i1 %[[VAL_39]], label %[[VAL_40:.*]], label %[[VAL_41:.*]]
// CHECK:       initialized-after:                                ; preds = %[[VAL_41]], %[[VAL_42:.*]]
// CHECK:         br label %[[VAL_23]]
// CHECK:       in-bounds-false:                                  ; preds = %[[VAL_27]]
// CHECK:         br label %[[VAL_23]]
// CHECK:       initialized-true:                                 ; preds = %[[VAL_33]]
// CHECK:         %[[VAL_43:.*]] = getelementptr inbounds [6 x float], ptr %[[VAL_5]], i32 0, i32 %[[VAL_30]]
// CHECK:         call void @region_0_4(ptr %[[VAL_4]], ptr %[[VAL_43]], ptr %[[VAL_0]])
// CHECK:         %[[VAL_44:.*]] = load i8, ptr %[[VAL_0]], align 1
// CHECK:         %[[VAL_45:.*]] = icmp ne i8 %[[VAL_44]], 0
// CHECK:         br i1 %[[VAL_45]], label %[[VAL_46:.*]], label %[[VAL_47:.*]]
// CHECK:       if-select-lhs-after:                              ; preds = %[[VAL_47]], %[[VAL_46]]
// CHECK:         br label %[[VAL_35]]
// CHECK:       initialized-false:                                ; preds = %[[VAL_33]]
// CHECK:         %[[VAL_48:.*]] = getelementptr inbounds [6 x float], ptr %[[VAL_5]], i32 0, i32 %[[VAL_30]]
// CHECK:         %[[VAL_49:.*]] = load float, ptr %[[VAL_48]], align 4, !invariant.load !4
// CHECK:         store float %[[VAL_49]], ptr %[[VAL_4]], align 4
// CHECK:         %[[VAL_50:.*]] = getelementptr inbounds i32, ptr %[[VAL_3]], i32 0
// CHECK:         store i32 %[[VAL_30]], ptr %[[VAL_50]], align 4
// CHECK:         store i1 true, ptr %[[VAL_2]], align 1
// CHECK:         br label %[[VAL_35]]
// CHECK:       if-select-lhs-true:                               ; preds = %[[VAL_40]]
// CHECK:         br label %[[VAL_42]]
// CHECK:       if-select-lhs-false:                              ; preds = %[[VAL_40]]
// CHECK:         %[[VAL_51:.*]] = load float, ptr %[[VAL_43]], align 4
// CHECK:         store float %[[VAL_51]], ptr %[[VAL_4]], align 4
// CHECK:         %[[VAL_52:.*]] = getelementptr inbounds i32, ptr %[[VAL_3]], i32 0
// CHECK:         store i32 %[[VAL_30]], ptr %[[VAL_52]], align 4
// CHECK:         br label %[[VAL_42]]
// CHECK:       should-store-true:                                ; preds = %[[VAL_26]]
// CHECK:         %[[VAL_53:.*]] = getelementptr inbounds i32, ptr %[[VAL_3]], i32 0
// CHECK:         %[[VAL_54:.*]] = load i32, ptr %[[VAL_53]], align 4
// CHECK:         %[[VAL_55:.*]] = getelementptr inbounds float, ptr %[[VAL_7]], i32 %[[VAL_14]]
// CHECK:         %[[VAL_56:.*]] = getelementptr inbounds [6 x float], ptr %[[VAL_9]], i32 0, i32 %[[VAL_54]]
// CHECK:         %[[VAL_57:.*]] = load float, ptr %[[VAL_55]], align 4
// CHECK:         %[[VAL_58:.*]] = atomicrmw fadd ptr %[[VAL_56]], float %[[VAL_57]] seq_cst, align 4
// CHECK:         br label %[[VAL_20]]
// CHECK:       entry:
// CHECK:         %[[VAL_59:.*]] = alloca i8, align 1
// CHECK:         %[[VAL_60:.*]] = load float, ptr %[[VAL_61:.*]], align 4
// CHECK:         %[[VAL_62:.*]] = load float, ptr %[[VAL_63:.*]], align 4
// CHECK:         %[[VAL_64:.*]] = fcmp oge float %[[VAL_60]], %[[VAL_62]]
// CHECK:         %[[VAL_65:.*]] = zext i1 %[[VAL_64]] to i8
// CHECK:         store i8 %[[VAL_65]], ptr %[[VAL_59]], align 1
// CHECK:         %[[VAL_66:.*]] = load i8, ptr %[[VAL_59]], align 1
// CHECK:         store i8 %[[VAL_66]], ptr %[[VAL_67:.*]], align 1
// CHECK:         ret void

HloModule SelectAndScatter

%ge_F32 (lhs.5: f32[], rhs.6: f32[]) -> pred[] {
  %lhs.5 = f32[] parameter(0)
  %rhs.6 = f32[] parameter(1)
  ROOT %compare.7 = pred[] compare(f32[] %lhs.5, f32[] %rhs.6), direction=GE
}

%add_F32 (lhs.9: f32[], rhs.10: f32[]) -> f32[] {
  %lhs.9 = f32[] parameter(0)
  %rhs.10 = f32[] parameter(1)
  ROOT %add.11 = f32[] add(f32[] %lhs.9, f32[] %rhs.10)
}

ENTRY main () -> f32[6] {
  %operand = f32[6]{0} parameter(0)
  %source = f32[2]{0} parameter(1)
  %init = f32[] constant(0)
  ROOT %select_and_scatter_12 = f32[6]{0} select-and-scatter(f32[6]{0} %operand, f32[2]{0} %source, f32[] %init), window={size=3 stride=3}, select=%ge_F32, scatter=%add_F32
}
